{
    "Strangler Fig": "1. Identify the order by which you want to extract the functionalities\n2.Gradually move functionality over to the new microservices architecture. This technique usually uses as the main refactoring the extract service refactoring.\n3. Reroute calls from the monolith over to the new microservice using the change local method call dependency to a service cal.\n4.If the new extracted functionality uses functionalities that remain inside the monolith, then the monolith can expose this functionality. \n\nDo this by replacing or rewriting existing features parallel to the old architecture, one at a time, until the old architecture has been entirely replaced. Usually, we must create a proxy or fa√ßade that provides a stable API for old clients throughout the migration.\n", 
    "Extract Service": "1. Analyse all the dependencies of the functionality we will extract to a service.\n2. Resolve these dependencies. This usually involves refactoring foreign keys and changing method calls to other files/classes/etc. to remote calls (synchronous or asynchronous).\n3. If external libraries are dependencies, they will later need to be added to the new service.\n4. Create a file (that, if the project is object-oriented, will represent a class).\n5. Rewrite a class making all its methods into remote service methods.\n6. Partition class methods into service and regular methods, rewriting all the communication between the two into remote service calls.\n7. Re-target all clients of the original class to access its cloud functionality through remote service calls.\n8. Add fault handling functionality to client code.\n",
    "Change Data Ownership": "", 
    "Move Foreign-key relationship": "",
    "Data Type Dependency": ""
}